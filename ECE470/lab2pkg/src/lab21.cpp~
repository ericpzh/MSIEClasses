#include "lab2pkg/lab2.h"
#define PI 3.14159265359
#define SPIN_RATE 20  /* Hz */

//arrays defining Waypoints
double home[]={119.96*PI/180,-88.81*PI/180,86.84*PI/180,-87.03*PI/180,-89.95*PI/180,0.14*PI/180};

double arr11[]={110.71*PI/180,-61.59*PI/180,78.82*PI/180,-104.21*PI/180,-90.13*PI/180,350.82*PI/180};
double arr12[]={110.71*PI/180,-52.25*PI/180,88.29*PI/180,-125.01*PI/180,-90.13*PI/180,350.82*PI/180};
double arr13[]={110.71*PI/180,-47.17*PI/180,90.18*PI/180,-131.99*PI/180,-90.13*PI/180,350.74*PI/180};
double arr14[]={110.71*PI/180,-42.04*PI/180,90.78*PI/180,-137.71*PI/180,-90.13*PI/180,350.82*PI/180};

double arr21[] = {119.96*PI/180,-84.18*PI/180,109.14*PI/180,-113.97*PI/180,-89.95*PI/180,0.07*PI/180};
double arr22[] = {120*PI/180,-70.81*PI/180,120.53*PI/180,-138.73*PI/180,-90*PI/180,359.99*PI/180};
double arr23[] = {119.96*PI/180,-64.18*PI/180,112.56*PI/180,-147.37*PI/180,-89.95*PI/180,359.97*PI/180};
double arr24[] = {119.96*PI/180,-55.58*PI/180,123.5*PI/180,-156.9*PI/180,-89.95*PI/180,359.97*PI/180};

double arr31[] = {137.78*PI/180,-101.53*PI/180,123.78*PI/180,-111.37*PI/180,-89.95*PI/180,17.89*PI/180};
double arr32[] = {137.78*PI/180,-82.11*PI/180,139.45*PI/180,-146.45*PI/180,-89.95*PI/180,17.89*PI/180};
double arr33[] = {137.78*PI/180,-73.02*PI/180,141.75*PI/180,-157.84*PI/180,-89.95*PI/180,17.89*PI/180};
double arr34[] = {137.78*PI/180,-61.63*PI/180,142.8*PI/180,-170.28*PI/180,-89.95*PI/180,17.89*PI/180};

// array to define final velocity of point to point moves.  For now slow down to zero once
// each point is reached
double arrv[]={0,0,0,0,0,0};

//vectors to be used to publish commands to UR3 ROS Driver (ece470_ur3_driver)
std::vector<double> QH (home,home+sizeof(home) / sizeof(home[0]));

std::vector<double> Q11 (arr11,arr11+sizeof(arr11) / sizeof(arr11[0]));
std::vector<double> Q12 (arr12,arr12+sizeof(arr12) / sizeof(arr12[0]));
std::vector<double> Q13 (arr13,arr13+sizeof(arr13) / sizeof(arr13[0]));
std::vector<double> Q14 (arr14,arr14+sizeof(arr14) / sizeof(arr14[0]));
std::vector<double> Q21 (arr21,arr21+sizeof(arr21) / sizeof(arr21[0]));
std::vector<double> Q22 (arr22,arr22+sizeof(arr22) / sizeof(arr22[0]));
std::vector<double> Q23 (arr21,arr23+sizeof(arr23) / sizeof(arr23[0]));
std::vector<double> Q24 (arr21,arr24+sizeof(arr24) / sizeof(arr24[0]));
std::vector<double> Q31 (arr31,arr31+sizeof(arr31) / sizeof(arr31[0]));
std::vector<double> Q32 (arr32,arr32+sizeof(arr32) / sizeof(arr32[0]));
std::vector<double> Q33 (arr33,arr33+sizeof(arr33) / sizeof(arr33[0]));
std::vector<double> Q34 (arr34,arr34+sizeof(arr34) / sizeof(arr34[0]));
std::vector<double> v (arrv,arrv+sizeof(arrv) / sizeof(arrv[0]));

// creating an array of these vectors allows us to iterate through them
// and programatically choose where to go.
std::vector<double> Q [4][3] = {
    {Q11, Q21, Q31},
    {Q12, Q22, Q32},
    {Q13, Q23, Q33},
    {Q14, Q24, Q34}
};


// Global bool variables that are assigned in the callback associated when subscribed
// to the "ur3/position" topic
bool isReady=1;
bool pending=0;

// Whenever ur3/position publishes info this callback function is run.
void position_callback(const ece470_ur3_driver::positions::ConstPtr& msg)
{
	isReady=msg->isReady; // When isReady is True the robot arm has made it to its desired position
						  // and is ready to be told to go to another point if desired.
	pending=msg->pending; // pending is the opposite of isReady, pending is true until a new position is reached
//	ROS_INFO("Debug isRdy = %d, pending = %d",(int)isReady,(int)pending);
}


int move_arm(	ros::Publisher pub_command , ros::Rate loop_rate, std::vector<double> dest, float duration)
{
    int error = 0;
    return error;
}

int move_block(ros::Publisher pub_command ,
                ros::Rate loop_rate,
                ros::ServiceClient srv_SetIO,
                ur_msgs::SetIO srv,
                int start_loc,
                int start_height,
                int end_loc,
                int end_height)
{
    int error = 0;
    return error;
}

int main(int argc, char **argv)//ur robot's IP. 
{

	int inputdone = 0;
	int Loopcnt = 0;
//initialization & variable definition
	ros::init(argc, argv, "lab2node");	//initialzation of ros required for each Node.
	ros::NodeHandle nh;				//handler for this node.

	//initialized publisher ur3/command, buffer size of 10.
	ros::Publisher pub_command=nh.advertise<ece470_ur3_driver::command>("ur3/command",10);
	// initialize subscriber to ur3/position and call function position_callback each time data is published
	ros::Subscriber sub_position=nh.subscribe("ur3/position",1,position_callback);

	ros::ServiceClient srv_SetIO = nh.serviceClient<ur_msgs::SetIO>("ur_driver/set_io");
	ur_msgs::SetIO srv;

	ece470_ur3_driver::command driver_msg;

	std::string inputString;
	while (!inputdone) {
		std::cout << "Enter Number of Loops <Either 1 2 or 3>";
		std::getline(std::cin, inputString);
		std::cout << "You entered " << inputString << "\n";
		if (inputString == "1") {
			inputdone = 1;
			Loopcnt = 1;
		} else if (inputString == "2") {
			inputdone = 1;
			Loopcnt = 2;
		} else if (inputString == "3") {
			inputdone = 1;
			Loopcnt = 3;
		} else {
			std:cout << "Please just enter the character 1 2 or 3\n\n";
		}
	}

	while(!ros::ok()){};	//check if ros is ready for operation

	ROS_INFO("sending Goals");

	ros::Rate loop_rate(SPIN_RATE); // Initialize the rate to publish to ur3/command
	int spincount = 0;
	while(Loopcnt > 0) {
		driver_msg.destination=QH;  // Set desired position to move home
		pub_command.publish(driver_msg);  // publish command, but note that is possible that											  // the subscriber will not receive this message.
		spincount = 0;
		while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
			ros::spinOnce();  // Allow other ROS functionallity to run
			loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
			if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
				pub_command.publish(driver_msg);
				ROS_INFO("Just Published again driver_msg");
				spincount = 0;
			}
			spincount++;  // keep track of loop count
		}
    //
    //QH -> [1][1]
    //
		ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
		while(!isReady)
		{
			ros::spinOnce();
			loop_rate.sleep();
		}
		ROS_INFO("sending Goals 1");
		driver_msg.destination=Q[0][1];
		pub_command.publish(driver_msg);  // publish command, but note that is possible that											  // the subscriber will not receive this message.
		spincount = 0;
		while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
			ros::spinOnce();  // Allow other ROS functionallity to run
			loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
			if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
				pub_command.publish(driver_msg);
				ROS_INFO("Just Published again driver_msg");
				spincount = 0;
			}
			spincount++;  // keep track of loop count
		}
    //[1][1]
    //pickup
    // [0][1]
		ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
		while(!isReady)
		{
			ros::spinOnce();
			loop_rate.sleep();
		}
		srv.request.fun = 1;
		srv.request.pin = 0;  //Digital Output 0
		srv.request.state = 1.0; //Set DO0 on
		if (srv_SetIO.call(srv)) {
			ROS_INFO("True: Switched Suction ON");
		} else {
			ROS_INFO("False");
		}
    //
    //if(analog 0 != 0)not
    //break/return 0;
    //print error
    //
		ROS_INFO("sending Goals 2");
		driver_msg.destination=Q[0][0];
		driver_msg.duration=2.0;
		pub_command.publish(driver_msg);  // publish command, but note that is possible that										  // the subscriber will not receive this message.
		spincount = 0;
		while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
			ros::spinOnce();  // Allow other ROS functionallity to run
			loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
			if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
				pub_command.publish(driver_msg);
				ROS_INFO("Just Published again driver_msg");
				spincount = 0;
			}
			spincount++;  // keep track of loop count
		}
    //[0][1]
    //
    // [0][2]
		ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
		while(!isReady)
		{
			ros::spinOnce();
			loop_rate.sleep();
		}
		ROS_INFO("sending Goals 3");
		driver_msg.destination=Q[0][0];
		driver_msg.duration=1.0;
		pub_command.publish(driver_msg);  // publish command, but note that is possible that											  // the subscriber will not receive this message.
		spincount = 0;
		while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
			ros::spinOnce();  // Allow other ROS functionallity to run
			loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
			if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
				pub_command.publish(driver_msg);
				ROS_INFO("Just Published again driver_msg");
				spincount = 0;
			}
			spincount++;  // keep track of loop count
		}
    //[0][2]
    //
    // [3][2]
		ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
		while(!isReady)
		{
			ros::spinOnce();
			loop_rate.sleep();
		}
    ROS_INFO("sending Goals 4");
    driver_msg.destination=Q[0][0];
    driver_msg.duration=1.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that											  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }
    //[3][2]
    // put down
    // [0][2]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
    while(!isReady)
    {
      ros::spinOnce();
      loop_rate.sleep();
    }
    srv.request.fun = 1;
    srv.request.pin = 0;  //Digital Output 0
    srv.request.state = 0.0; //Set DO0 on
    if (srv_SetIO.call(srv)) {
      ROS_INFO("True: Switched Suction OFF");
    } else {
      ROS_INFO("False");
    }
    ROS_INFO("sending Goals 5");
    driver_msg.destination=Q[0][2];
    driver_msg.duration=2.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that										  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }
    //[0][2]
    //
    // [0][1]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
		while(!isReady)
		{
			ros::spinOnce();
			loop_rate.sleep();
		}
    ROS_INFO("sending Goals 6");
    driver_msg.destination=Q[0][1];
    driver_msg.duration=1.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that											  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }
    //[0][1]
    //
    // [2][1]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
		while(!isReady)
		{
			ros::spinOnce();
			loop_rate.sleep();
		}
    ROS_INFO("sending Goals 7");
    driver_msg.destination=Q[2][1];
    driver_msg.duration=1.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that											  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }
    //[2][1]
    // pick up
    // [0][1]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
    while(!isReady)
    {
      ros::spinOnce();
      loop_rate.sleep();
    }
    srv.request.fun = 1;
    srv.request.pin = 0;  //Digital Output 0
    srv.request.state = 1.0; //Set DO0 on
    if (srv_SetIO.call(srv)) {
      ROS_INFO("True: Switched Suction ON");
    } else {
      ROS_INFO("False");
    }
    ROS_INFO("sending Goals 5");
    driver_msg.destination=Q[0][1];
    driver_msg.duration=2.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that										  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }
    //[0][1]
    //
    // [0][0]


    //[0][0]
    //
    // [3][0]


    //[3][0]
    // putdown
    // [0][0]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
    while(!isReady)
    {
      ros::spinOnce();
      loop_rate.sleep();
    }
    srv.request.fun = 1;
    srv.request.pin = 0;  //Digital Output 0
    srv.request.state = 0.0; //Set DO0 off
    if (srv_SetIO.call(srv)) {
      ROS_INFO("True: Switched Suction OFF");
    } else {
      ROS_INFO("False");
    }
    ROS_INFO("sending Goals 5");
    driver_msg.destination=Q[0][0];
    driver_msg.duration=2.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that										  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }
    //[0][0]
    //
    // [0][2]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
		while(!isReady)
		{
			ros::spinOnce();
			loop_rate.sleep();
		}
    ROS_INFO("sending Goals 6");
    driver_msg.destination=Q[0][2];
    driver_msg.duration=1.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that											  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }

    //[0][2]
    //
    // [3][2]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
		while(!isReady)
		{
			ros::spinOnce();
			loop_rate.sleep();
		}
    ROS_INFO("sending Goals 6");
    driver_msg.destination=Q[3][2];
    driver_msg.duration=1.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that											  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command06230590]: sending Goals 7

      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }

    //[3][2]
    //pick up
    // [0][2]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
    while(!isReady)
    {
      ros::spinOnce();
      loop_rate.sleep();
    }
    srv.request.fun = 1;
    srv.request.pin = 0;  //Digital Output 0
    srv.request.state = 1.0; //Set DO0 on
    if (srv_SetIO.call(srv)) {
      ROS_INFO("True: Switched Suction ON");
    } else {
      ROS_INFO("False");
    }
    ROS_INFO("sending Goals 5");
    driver_msg.destination=Q[0][2];
    driver_msg.duration=2.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that										  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }
    //[0][2]
    //
    // [0][0]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
		while(!isReady)
		{
			ros::spinOnce();
			loop_rate.sleep();
		}
    ROS_INFO("sending Goals 6");
    driver_msg.destination=Q[0][0];
    driver_msg.duration=1.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that											  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }
    //[0][0]
    //
    // [2][0]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
		while(!isReady)
		{
			ros::spinOnce();
			loop_rate.sleep();
		}
    ROS_INFO("sending Goals 6");
    driver_msg.destination=Q[2][0];
    driver_msg.duration=1.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that											  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }
    //[2][0]
    // put down
    // [0][0]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
    while(!isReady)
    {
      ros::spinOnce();
      loop_rate.sleep();
    }
    srv.request.fun = 1;
    srv.request.pin = 0;  //Digital Output 0
    srv.request.state = 0.0; //Set DO0 off
    if (srv_SetIO.call(srv)) {
      ROS_INFO("True: Switched Suction OFF");
    } else {
      ROS_INFO("False");
    }
    ROS_INFO("sending Goals 5");
    driver_msg.destination=Q[0][0];
    driver_msg.duration=2.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that										  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }
    //[0][0]
    //
    // [0][1]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
		while(!isReady)
		{
			ros::spinOnce();
			loop_rate.sleep();
		}
    ROS_INFO("sending Goals 6");
    driver_msg.destination=Q[0][1];
    driver_msg.duration=1.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that											  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }
    //[0][1]
    //
    // [3][1]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
		while(!isReady)
		{
			ros::spinOnce();
			loop_rate.sleep();
		}
    ROS_INFO("sending Goals 6");
    driver_msg.destination=Q[3][1];
    driver_msg.duration=1.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that											  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }

    //[3][1]
    // pick up
    // [0][1]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
    while(!isReady)
    {
      ros::spinOnce();
      loop_rate.sleep();
    }
    srv.request.fun = 1;
    srv.request.pin = 0;  //Digital Output 0
    srv.request.state = 1.0; //Set DO0 on
    if (srv_SetIO.call(srv)) {
      ROS_INFO("True: Switched Suction ON");
    } else {
      ROS_INFO("False");
    }
    ROS_INFO("sending Goals 5");
    driver_msg.destination=Q[0][1];
    driver_msg.duration=2.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that										  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }
    //[0][1]
    //
    // [0][2]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
		while(!isReady)
		{
			ros::spinOnce();
			loop_rate.sleep();
		}
    ROS_INFO("sending Goals 6");
    driver_msg.destination=Q[0][2];
    driver_msg.duration=1.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that											  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }

    //[0][2]
    //
    // [3][2]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
		while(!isReady)
		{
			ros::spinOnce();
			loop_rate.sleep();
		}
    ROS_INFO("sending Goals 6");
    driver_msg.destination=Q[3][2];
    driver_msg.duration=1.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that											  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }

    //[3][2]
    // putdown
    // [0][2]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
    while(!isReady)
    {
      ros::spinOnce();
      loop_rate.sleep();
    }
    srv.request.fun = 1;
    srv.request.pin = 0;  //Digital Output 0
    srv.request.state = 0.0; //Set DO0 off
    if (srv_SetIO.call(srv)) {
      ROS_INFO("True: Switched Suction OFF");
    } else {
      ROS_INFO("False");
    }
    ROS_INFO("sending Goals 5");
    driver_msg.destination=Q[0][2];
    driver_msg.duration=2.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that										  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }
    //[0][2]
    //
    // [0][0]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
		while(!isReady)
		{
			ros::spinOnce();
			loop_rate.sleep();
		}
    ROS_INFO("sending Goals 6");
    driver_msg.destination=Q[0][0];
    driver_msg.duration=1.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that											  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }

    //[0][0]
    //
    // [2][0]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
		while(!isReady)
		{
			ros::spinOnce();
			loop_rate.sleep();
		}
    ROS_INFO("sending Goals 6");
    driver_msg.destination=Q[2][0];
    driver_msg.duration=1.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that											  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }

    //[2][0]
    // pick up
    // [0][0]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
    while(!isReady)
    {
      ros::spinOnce();
      loop_rate.sleep();
    }
    srv.request.fun = 1;
    srv.request.pin = 0;  //Digital Output 0
    srv.request.state = 1.0; //Set DO0 on
    if (srv_SetIO.call(srv)) {
      ROS_INFO("True: Switched Suction ON");
    } else {
      ROS_INFO("False");
    }
    ROS_INFO("sending Goals 5");
    driver_msg.destination=Q[0][0];
    driver_msg.duration=2.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that										  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }
    //[0][0]
    //
    // [0][1]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
		while(!isReady)
		{
			ros::spinOnce();
			loop_rate.sleep();
		}
    ROS_INFO("sending Goals 6");
    driver_msg.destination=Q[0][1];
    driver_msg.duration=1.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that											  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }

    //[0][1]
    //
    // [3][1]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
		while(!isReady)
		{
			ros::spinOnce();
			loop_rate.sleep();
		}
    ROS_INFO("sending Goals 6");
    driver_msg.destination=Q[3][1];
    driver_msg.duration=1.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that											  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }

    //[3][1]
    // put down
    // [0][1]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
    while(!isReady)
    {
      ros::spinOnce();
      loop_rate.sleep();
    }
    srv.request.fun = 1;
    srv.request.pin = 0;  //Digital Output 0
    srv.request.state = 0.0; //Set DO0 off
    if (srv_SetIO.call(srv)) {
      ROS_INFO("True: Switched Suction OFF");
    } else {
      ROS_INFO("False");
    }
    ROS_INFO("sending Goals 5");
    driver_msg.destination=Q[0][1];
    driver_msg.duration=2.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that										  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }
    //[0][1]
    //
    // [0][0]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
		while(!isReady)
		{
			ros::spinOnce();
			loop_rate.sleep();
		}
    ROS_INFO("sending Goals 6");
    driver_msg.destination=Q[0][0];
    driver_msg.duration=1.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that											  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }

    //[0][0]
    //
    // [3][0]

    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
		while(!isReady)
		{
			ros::spinOnce();
			loop_rate.sleep();
		}
    ROS_INFO("sending Goals 6");
    driver_msg.destination=Q[3][0];
    driver_msg.duration=1.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that											  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }
    //[3][0]
    // pick up
    // [0][0]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
    while(!isReady)
    {
      ros::spinOnce();
      loop_rate.sleep();
    }
    srv.request.fun = 1;
    srv.request.pin = 0;  //Digital Output 0
    srv.request.state = 1.0; //Set DO0 on
    if (srv_SetIO.call(srv)) {
      ROS_INFO("True: Switched Suction ON");
    } else {
      ROS_INFO("False");
    }
    ROS_INFO("sending Goals 5");
    driver_msg.destination=Q[0][0];
    driver_msg.duration=2.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that										  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }
    //[0][0]
    //
    // [0][2]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
		while(!isReady)
		{
			ros::spinOnce();
			loop_rate.sleep();
		}
    ROS_INFO("sending Goals 6");
    driver_msg.destination=Q[0][2];
    driver_msg.duration=1.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that											  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }

    //[0][2]
    //
    // [2][2]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
		while(!isReady)
		{
			ros::spinOnce();
			loop_rate.sleep();
		}
    ROS_INFO("sending Goals 6");
    driver_msg.destination=Q[2][2];
    driver_msg.duration=1.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that											  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }

    //[2][2]
    // put down
    // [0][2]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
    while(!isReady)
    {
      ros::spinOnce();
      loop_rate.sleep();
    }
    srv.request.fun = 1;
    srv.request.pin = 0;  //Digital Output 0
    srv.request.state = 0.0; //Set DO0 off
    if (srv_SetIO.call(srv)) {
      ROS_INFO("True: Switched Suction OFF");
    } else {
      ROS_INFO("False");
    }
    ROS_INFO("sending Goals 5");
    driver_msg.destination=Q[0][2];
    driver_msg.duration=2.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that										  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }
    //[0][2]
    //
    // [0][1]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
		while(!isReady)
		{
			ros::spinOnce();
			loop_rate.sleep();
		}
    ROS_INFO("sending Goals 6");
    driver_msg.destination=Q[0][1];
    driver_msg.duration=1.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that											  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }
    //[0][1]
    //
    // [3][1]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
		while(!isReady)
		{
			ros::spinOnce();
			loop_rate.sleep();
		}
    ROS_INFO("sending Goals 6");
    driver_msg.destination=Q[3][1];
    driver_msg.duration=1.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that											  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }
    //[3][1]
    // pick up
    // [0][1]
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
    while(!isReady)
    {
      ros::spinOnce();
      loop_rate.sleep();
    }
    srv.request.fun = 1;
    srv.request.pin = 0;  //Digital Output 0
    srv.request.state = 1.0; //Set DO0 on
    if (srv_SetIO.call(srv)) {
      ROS_INFO("True: Switched Suction ON");
    } else {
      ROS_INFO("False");
    }
    ROS_INFO("sending Goals 5");
    driver_msg.destination=Q[0][1];
    driver_msg.duration=2.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that										  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }
    //[0][1]
    //
    // [0][2]

    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
		while(!isReady)
		{
			ros::spinOnce();
			loop_rate.sleep();
		}
    ROS_INFO("sending Goals 6");
    driver_msg.destination=Q[0][2];
    driver_msg.duration=1.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that											  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }
    //[0][2]
    //
    // [1][2]

    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
		while(!isReady)
		{
			ros::spinOnce();
			loop_rate.sleep();
		}
    ROS_INFO("sending Goals 6");
    driver_msg.destination=Q[1][2];
    driver_msg.duration=1.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that											  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }
    //[1][2]
    // put down
    // QH
    ROS_INFO("waiting for rdy");  // Now wait for robot arm to reach the commanded waypoint.
    while(!isReady)
    {
      ros::spinOnce();
      loop_rate.sleep();
    }
    srv.request.fun = 1;
    srv.request.pin = 0;  //Digital Output 0
    srv.request.state = 0.0; //Set DO0 off
    if (srv_SetIO.call(srv)) {
      ROS_INFO("True: Switched Suction OFF");
    } else {
      ROS_INFO("False");
    }
    ROS_INFO("sending Goals 5");
    driver_msg.destination=QH;
    driver_msg.duration=2.0;
    pub_command.publish(driver_msg);  // publish command, but note that is possible that										  // the subscriber will not receive this message.
    spincount = 0;
    while (isReady) { // Waiting for isReady to be false meaning that the driver has the new command
      ros::spinOnce();  // Allow other ROS functionallity to run
      loop_rate.sleep(); // Sleep and wake up at 1/20 second (1/SPIN_RATE) interval
      if (spincount > SPIN_RATE) {  // if isReady does not get set within 1 second re-publish
        pub_command.publish(driver_msg);
        ROS_INFO("Just Published again driver_msg");
        spincount = 0;
      }
      spincount++;  // keep track of loop count
    }
    
		Loopcnt--;
	}

	return 0;
}
